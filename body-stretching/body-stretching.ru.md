# Растягиваем body на всю высоту вьюпорта: недостающий способ

Итак, вы делаете sticky footer или центрирование контента относительно вьюпорта и хотите растянуть `body` на всю высоту окна браузера, позволив ему при этом расти вместе с контентом. Без сомнения, эта задача была решена уже много раз и никаких сложностей возникнуть не должно. Правда? _Правда?_

## Современный способ

Конечно! Нужно просто добавить `min-height: 100vh` для `body`. `100vh` - это же 100% высоты вьюпорта, а использование `min-height` вместо `height` не ограничит высоту `body` и позволит ему расти при необходимости. То что нужно!

Ну... Почти. Оказывается, в типичном мобильном браузере у страницы всегда будет скролл, а низ страницы будет скрываться под нижней панелью браузера. Даже в тех случаях, когда контент полностью влезает на один экран!

Дело в том, что на мобильных устройствах `100vh` - это максимально возможная высота вьюпорта, а изначальная высота вьюпорта обычно _меньше_ максимальной. Это происходит из-за того, что часть пространства занимают элементы UI браузера, которые уменьшаются или пропадают при скролле.

![Демонстрация скролла в мобильном браузере](./resources/100vh-scroll.png)

Можно нагуглить [фикс](https://css-tricks.com/css-fix-for-100vh-in-mobile-webkit/) для этой проблемы, который выглядит примерно так:

```css
html {
    height: -webkit-fill-available; /* Приходится фиксировать высоту html */
}

body {
    min-height: 100vh;
    min-height: -webkit-fill-available;
}
```

Почему-то в Chrome при изменении высоты вьюпорта `body` может не обновлять свою высоту. В остальном проблема действительно решается, но теперь мы вынуждены фиксировать высоту `html`. А раз так, то почему бы не использовать старое, более надежное решение?

## Олдскульный способ

Поскольку обойтись без фиксированной высоты для `html` не получилось, попробуем использовать старый добрый способ с прокидыванием 100% высоты от `html`.

Задаем для `body` `min-height: 100%`, где 100% - полная высота родителя (`html`). Указание высоты в процентах требует фиксированной высоты родителя, поэтому задаем для `html` `height: 100%`, фиксируя его высоту по вьюпорту.

Кстати, в случае мобильных браузеров высота в процентах для `html` задается относительно _минимальной_ высоты вьюпорта, поэтому упомянутая выше проблема со скроллом решается сама собой!

```css
html {
    height: 100%; /* Все еще приходится фиксировать высоту html */
}

body {
    min-height: 100%;
}
```

Это решение не такое красивое, как `100vh`, зато используется с незапамятных времен и точно должно работать!

Ну... Не совсем. Оказывается, если задать градиент для `body`, он будет обрезаться по высоте `html` (она же высота вьюпорта).

![Демонстрация обрезающегося градиента](resources/gradient-clip.png)

Конечно, можно "починить" это заданием градиента не для `body`, а для его содержимого, но это просто _неправильно_. Фон страницы _должен_ быть задан для `body`, а `html` _должен_ растягиваться по контенту. Это же возможно?

## Недостающий способ

Предлагаю еще один способ растянуть `body` по вьюпорту, лишенный упомянутых выше недостатков. Основная идея в том, что мы прокидываем 100% высоту от `html` с помощью flexbox, и поэтому можем не фиксировать высоту `html`.

```css
html {
    min-height: 100%; /* Высота больше не фиксированная! */
    
    display: flex;
    flex-direction: column;
}

body {
    flex-grow: 1;
}
```

Теперь `html` растягивается по контенту, и нет проблем с мобильными браузерами. Красота!

## Примечания

* Очевидно, прокидывание высоты с помощью flexbox работает на неограниченную глубину, и легко может быть использовано в ситуации, когда контент рендерится не в `body`, а в элемент внутри `body`. Это типичная ситуация при использовании, например, [React](https://medium.com/@dan_abramov/two-weird-tricks-that-fix-react-7cf9bbdef375) или [Vue](https://vuejs.org/v2/api/#el).
* Прокидывание высоты с помощью flexbox не работает в IE. Совсем. Но вы же не поддерживаете его, правда?